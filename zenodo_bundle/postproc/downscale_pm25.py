# python3 source code for pm2.5 downscaling tool.
# author: Knut von Salzen, email: knut.vonsalzen@canada.ca
#
# call this code after emulator_pm25.py and ensure that "indir"
# is pointing to the directory that contains the output generated by
# emulator_pm25.py.

import numpy as np
import xarray as xr
import sys
import re

### read file information

data_in = np.genfromtxt('downscale_pm25.csv', dtype="<U100,<U100,<U100", names=True, delimiter=',')
lenx = data_in['model'].size
if lenx == 1:
  model = [data_in['model']]
  model_dat_file0 = [data_in['model_dat_file']]
  dal_dat_file0 = [data_in['dal_dat_file']]
else:
  model = data_in['model']
  model_dat_file0 = data_in['model_dat_file']
  dal_dat_file0 = data_in['dal_dat_file']

# i/o routine and numerical parameter
  
def get_coord_size(varn,ncfile):                                # get size of the coordinate array
  coord = ncfile.variables[varn][:]
  ncoord = len(coord)
  return ncoord

fillv = -9999.

# directories containing the input files

indir = '../'
refdat = '../netcdf/'

# variables to be processed

model_var = ['pm25', 'pm25s', 'pm25bc', 'pm25oc']
nvar = len(model_var)
dal_var = 'PM25'
dal_orig_file = refdat+'GlobalGWRcwUni_PM25_GL_201501_201512-RH35_Median_NoDust_NoSalt_0.5deg.nc'

# loop over all data sets

for imod in range(lenx):
  model_dat_file = indir+str(model_dat_file0[imod])
  print('Model input file: '+model_dat_file)
  dal_dat_file = refdat+str(dal_dat_file0[imod])

# read input files
  
  ncfile   = xr.open_dataset(model_dat_file)
  if "UKESM" in model[imod]:
    latnam = 'latitude'
    lonnam = 'longitude'
  else:
    latnam = 'lat'
    lonnam = 'lon'
  nlat     = get_coord_size(latnam,ncfile)
  nlon     = get_coord_size(lonnam,ncfile)
  ntime    = get_coord_size('time',ncfile)
  lat      = ncfile.variables[latnam][:]
  lon      = ncfile.variables[lonnam][:]
  time     = ncfile.variables['time'][:]
  pm25ini = np.zeros((nvar,ntime,nlat,nlon))
  pm25in_lng = np.full((nvar),'                                                          ')
  pm25in_std = np.full((nvar),'                                                          ')
  for iv in range(nvar):
    pm25in   = ncfile.variables[model_var[iv]][:]
    pm25in_lng[iv]   = pm25in.attrs['long_name']
    pm25in_std[iv]   = pm25in.attrs['standard_name']
    print(model_var[iv])
    pm25ini[iv,:,:,:]  = pm25in[:,:,:]
  ncfile   = xr.open_dataset(dal_dat_file)
  PM25in   = ncfile.variables[dal_var][:]
  ncfile   = xr.open_dataset(dal_orig_file)
  PM25o    = ncfile.variables[dal_var][:]

# shift grid, if necessary
  
  lont = np.zeros((nlon))
  pm25t = np.zeros((nvar,ntime,nlat,nlon))
  nlonho = int(nlon/2)
  if lon[0] >= 0.:
    for jx in range(nlon):
      if jx < nlonho:
        j = jx + nlonho
        lont[j] = lon[jx]
      else:
        j = jx - nlonho
        lont[j] = lon[jx] - 360.
      pm25t[:,:,:,j] = pm25ini[:,:,:,jx].values
    lon = lont
    pm25ini = pm25t
  PM25in = PM25in.values
  PM25o = PM25o.values

# copy the model data set, targetting a 0.5 degree lat/lon grid

  nlatn = 360
  nlonn = 720
  nlonh = 360
  if (nlatn != nlat) or (nlonn != nlon):
    print('Incorrect number of grid points')
    sys.exit()
  pm25 = np.zeros((nlatn,nlonn))
  pm25to = np.zeros((nvar,ntime,nlatn,nlonn))
  for iv in range(nvar):
   for it in range(ntime):
    for ix in range(nlatn):
      for jx in range(nlonn):
        pm25[ix,jx] = pm25ini[iv,it,ix,jx]
    nlatt = nlatn
    nlont = nlonn

# ratio of model PM25 over Dalhousie PM25 on 0.5 degree grid

    pm25inx = pm25
    PM25inx = PM25o
    pm25R = np.reshape(pm25inx, nlatn*nlonn)
    PM25R = np.reshape(PM25inx, nlatn*nlonn)
    maskm = np.isnan(pm25R)
    pm25R[maskm] = fillv
    mask = ~np.isnan(PM25R) & (PM25R > 0.) & (PM25R < 10000.)
    rato = np.full((nlatn*nlonn),1.)
    rato[mask] = np.divide(pm25R[mask],PM25R[mask])

# reshape

    ratot = np.reshape(rato, (nlatn*nlonn))

# ratio of model PM25 over Dalhousie PM25 on model grid

    pm25iny = pm25ini[iv,it,:,:]
    PM25iny = PM25in
    PM25Rn = np.zeros((nlat*nlon))
    pm25Rn = np.zeros((nlat*nlon))
    jtx = 0
    for ix in range(nlat):
      for jx in range(nlon):
        PM25Rn[jtx] = PM25iny[ix,jx]
        pm25Rn[jtx] = pm25iny[ix,jx]
        jtx = jtx + 1
    mask = ~np.isnan(PM25Rn) & (PM25Rn > 0.) & (PM25Rn < 10000.)
    rat = np.full((nlat*nlon),1.)
    rat = ratot
    rat[mask] = np.divide(pm25Rn[mask],PM25Rn[mask])

# reshape

    ratt = np.reshape(rat, (nlat*nlon))
    maskt = np.reshape(mask, (nlat*nlon))
    pm25_rat = np.zeros((nlat,nlon))
    maskr = np.zeros((nlat,nlon))
    jtx = 0
    for ix in range(nlat):
      for jx in range(nlon):
        pm25_rat[ix,jx] = ratt[jtx]
        maskr[ix,jx] = maskt[jtx]
        jtx = jtx + 1

# fill grid points along coast lines

    for i in range(nlat):
      for j in range(nlon-1):
        if maskr[i,j] and not maskr[i,j+1]:
          pm25_rat[i,j+1] = pm25_rat[i,j]
        elif not maskr[i,j] and maskr[i,j+1]:
          pm25_rat[i,j] = pm25_rat[i,j+1]
      if maskr[i,j] and not maskr[i,0]:
        pm25_rat[i,0] = pm25_rat[i,j]
      elif not maskr[i,j] and maskr[i,0]:
        pm25_rat[i,j] = pm25_rat[i,0]
    for j in range(nlon):
      for i in range(nlat-1):
        if maskr[i,j] and not maskr[i+1,j]:
          pm25_rat[i+1,j] = pm25_rat[i,j]
        elif not maskr[i,j] and maskr[i+1,j]:
          pm25_rat[i,j] = pm25_rat[i+1,j]
      if maskr[i,j] and not maskr[0,j]:
        pm25_rat[0,j] = pm25_rat[i,j]
      elif not maskr[i,j] and maskr[0,j]:
        pm25_rat[i,j] = pm25_rat[0,j]

# multiply Dalhousie data set by scaling factor
        
    pm25 = np.multiply(pm25_rat,PM25o)
    pm25r = np.zeros((nlatn*nlonn))
    pm25f = np.zeros((nlatn*nlonn))
    itx = 0
    for i in range(nlatn):
      for j in range(nlonn):
        pm25r[itx] = pm25[i,j]
        itx = itx + 1
    mask = ~np.isnan(pm25r)
    pm25f[:] = fillv
    pm25f[mask] = pm25r[mask]
    pm25f[maskm] = fillv
    itx = 0
    for i in range(nlatn):
      for j in range(nlonn):
        pm25[i,j] = pm25f[itx]
        itx = itx + 1
    pm25to[iv,it,:,:]=pm25[:,:]

# output
    
  iv=0
  ds1 = xr.Dataset({model_var[iv]: (['time','lat','lon'], pm25to[iv,:,:,:])}, coords={'time':time,'lat':lat,'lon':lon})
  ds1.pm25.attrs = {('long_name', pm25in_lng[iv]),
                   ('standard_name',pm25in_std[iv]),
                   ('units','ug/m3'),
                   ('_FillValue', fillv)}
  if nvar >= 2:
    iv=1
    ds2 = xr.Dataset({model_var[iv]: (['time','lat','lon'], pm25to[iv,:,:,:])}, coords={'time':time,'lat':lat,'lon':lon})
    ds2.pm25s.attrs = {('long_name', pm25in_lng[iv]),
                     ('standard_name',pm25in_std[iv]),
                     ('units','ug/m3'),
                     ('_FillValue', fillv)}
  if nvar >= 3:
    iv=2
    ds3 = xr.Dataset({model_var[iv]: (['time','lat','lon'], pm25to[iv,:,:,:])}, coords={'time':time,'lat':lat,'lon':lon})
    ds3.pm25bc.attrs = {('long_name', pm25in_lng[iv]),
                     ('standard_name',pm25in_std[iv]),
                     ('units','ug/m3'),
                     ('_FillValue', fillv)}
  if nvar >= 4:
    iv=3
    ds4 = xr.Dataset({model_var[iv]: (['time','lat','lon'], pm25to[iv,:,:,:])}, coords={'time':time,'lat':lat,'lon':lon})
    ds4.pm25oc.attrs = {('long_name', pm25in_lng[iv]),
                     ('standard_name',pm25in_std[iv]),
                     ('units','ug/m3'),
                     ('_FillValue', fillv)}
  if nvar == 1:
    ds = ds1
  if nvar == 2:
    ds = xr.merge([ds1,ds2])
  if nvar == 3:
    ds = xr.merge([ds1,ds2,ds3])
  if nvar == 4:
    ds = xr.merge([ds1,ds2,ds3,ds4])
  ds.attrs = {('comment', 'contact: knut.vonsalzen@canada.ca'),
              ('data_licence', '1) GRANT OF LICENCE - The Government of Canada (Environment Canada) is the \
owner of all intellectual property rights (including copyright) that may exist in this Data \
product. You (as \"The Licensee\") are hereby granted a non-exclusive, non-assignable, \
non-transferable unrestricted licence to use this data product for any purpose including \
the right to share these data with others and to make value-added and derivative \
products from it. This licence is not a sale of any or all of the owner\'s rights.\
2) NO WARRANTY - This Data product is provided \"as-is\"; it has not been designed or \
prepared to meet the Licensee\'s particular requirements. Environment Canada makes no \
warranty, either express or implied, including but not limited to, warranties of \
merchantability and fitness for a particular purpose. In no event will Environment Canada \
be liable for any indirect, special, consequential or other damages attributed to the \
Licensee\'s use of the Data product.')}
  outfile = './pm25_downscaled_'+str(model[imod])+'.nc'
  ds.to_netcdf(outfile)

