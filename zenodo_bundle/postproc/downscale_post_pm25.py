# python3 source code for diagnosing population-weighted PM2.5 concentrations
# author: Knut von Salzen, email: knut.vonsalzen@canada.ca
#
# call this code after downscale_pm25.py and ensure that "indir"
# is pointing to the directory that contains the output generated by
# downscale_pm25.py. The base emulator configuration file (emulator.csv)
# also needs to be available in "indir".

import numpy as np
import os 
import sys
import xarray as xr
import re

# directory containing the input files

indir = '../'

### read scenario information
# possible choices are:
#   scenario = SSP126 SSP245 SSP370 SSP585 CLE MFR MFR_SDS CFM
#   realm = mean low_ecs high_ecs low_aci high_aci low_ari_bc high_ari_bc low_ari_s high_ari_s low_alb high_alb

data_in = np.genfromtxt(indir+'emulator.csv', dtype="<U100,<U100",names=True, delimiter=',')
scenario = str(data_in['scenario'])

# directory containting emulator data files

datdir = '../netcdf/'

# i/o routines and numerical parameters

fillv = -9999.

def get_coord_size(varn,ncfile):                                # get size of the coordinate array
  coord = ncfile.variables[varn][:]
  ncoord = len(coord)
  return ncoord

def get_coord_attr(varn,ncoord,ncfile):                         # get names associated with coordinate indices
  coord = ncfile.variables[varn][:]
  coord_attr = str(coord.attrs)
  coord_attspl = re.split('\d - ',coord_attr)                   # split long_name using integers as separator
  scoord = [" " for i in range(ncoord)]
  for n in range(ncoord):
    npt = n + 1
#    if npt < ncoord:                                             # remove redundant characters at the end of the string
    coord_attspl_len = len(coord_attspl[npt]) - 2
#    else:
#      coord_attspl_len = len(coord_attspl[npt]) - 4
    form = "".join(["{:.","{}".format(coord_attspl_len),"}"])   # determine format of the string
    scoord[n] = form.format(coord_attspl[npt])                   # read the string using the format
    scoord_attspl = re.split('\'',scoord[n])                    # split long_name using integers as separator
    coord_attspl_len = len(scoord_attspl) 
    if coord_attspl_len > 1:
      scoord[n] = scoord_attspl[0]
  return scoord

# read coordinate information from netcdf model data file

model_dat_file_mean = datdir+'pm25_downscaled_2015.nc'
ncfile   = xr.open_dataset(model_dat_file_mean)
nlat     = get_coord_size('lat',ncfile)
nlon     = get_coord_size('lon',ncfile)
lat      = ncfile.variables['lat'][:]
lon      = ncfile.variables['lon'][:]
pm25tot   = ncfile.variables['pm25'][:]
model_dat_file_mean = datdir+'pm25bc_downscaled_2015.nc'
ncfile   = xr.open_dataset(model_dat_file_mean)
nlat     = get_coord_size('lat',ncfile)
nlon     = get_coord_size('lon',ncfile)
lat      = ncfile.variables['lat'][:]
lon      = ncfile.variables['lon'][:]
pm25bc   = ncfile.variables['pm25'][:]
model_dat_file_mean = datdir+'pm25oc_downscaled_2015.nc'
ncfile   = xr.open_dataset(model_dat_file_mean)
nlat     = get_coord_size('lat',ncfile)
nlon     = get_coord_size('lon',ncfile)
lat      = ncfile.variables['lat'][:]
lon      = ncfile.variables['lon'][:]
pm25oc   = ncfile.variables['pm25'][:]
model_dat_file_mean = datdir+'pm25s_downscaled_2015.nc'
ncfile   = xr.open_dataset(model_dat_file_mean)
nlat     = get_coord_size('lat',ncfile)
nlon     = get_coord_size('lon',ncfile)
lat      = ncfile.variables['lat'][:]
lon      = ncfile.variables['lon'][:]
pm25s   = ncfile.variables['pm25'][:]
model_dat_file_mean = indir+'pm25_downscaled_emulator_'+scenario+'.nc'
ncfile   = xr.open_dataset(model_dat_file_mean)
nlat     = get_coord_size('lat',ncfile)
nlon     = get_coord_size('lon',ncfile)
ntime    = get_coord_size('time',ncfile)
lat      = ncfile.variables['lat'][:]
lon      = ncfile.variables['lon'][:]
time     = ncfile.variables['time'][:]
pm25bcs  = ncfile.variables['pm25bc'][:]
pm25ocs  = ncfile.variables['pm25oc'][:]
pm25ss   = ncfile.variables['pm25s'][:]
pm25tots = ncfile.variables['pm25'][:]
pm25_bc  = np.zeros((ntime,nlat,nlon), dtype=np.float32)
pm25_oc  = np.zeros((ntime,nlat,nlon), dtype=np.float32)
pm25_s   = np.zeros((ntime,nlat,nlon), dtype=np.float32)
pm25_tot = np.zeros((ntime,nlat,nlon), dtype=np.float32)
for nt in range(ntime):
  pm25_bc[nt,:,:]   = pm25bcs[nt,:,:]  + pm25bc
  pm25_oc[nt,:,:]   = pm25ocs[nt,:,:]  + pm25oc
  pm25_s[nt,:,:]    = pm25ss[nt,:,:]   + pm25s
  pm25_tot[nt,:,:]  = pm25tots[nt,:,:] + pm25tot
          
# write output file
        
ds1 = xr.Dataset({'pm25bc': (['time','lat','lon'], pm25_bc)}, coords={'time':time,'lat':lat,'lon':lon})
ds1.pm25bc.attrs = {('long_name', 'Mean PM2.5 concentration from emissions of BC'),
                  ('standard_name', 'pm25_concentration_bc'),
                  ('units', 'kg m-3'),
                  ('_FillValue', fillv)}
ds2 = xr.Dataset({'pm25oc': (['time','lat','lon'], pm25_oc)}, coords={'time':time,'lat':lat,'lon':lon})
ds2.pm25oc.attrs = {('long_name', 'Mean PM2.5 concentration from emissions of OC'),
                  ('standard_name', 'pm25_concentration_oc'),
                  ('units', 'kg m-3'),
                  ('_FillValue', fillv)}
ds3 = xr.Dataset({'pm25s': (['time','lat','lon'], pm25_s)}, coords={'time':time,'lat':lat,'lon':lon})
ds3.pm25s.attrs = {('long_name', 'Mean PM2.5 concentration from emissions of sulfur'),
                  ('standard_name', 'pm25_concentration_S'),
                  ('units', 'kg m-3'),
                  ('_FillValue', fillv)}
ds4 = xr.Dataset({'pm25': (['time','lat','lon'], pm25_tot)}, coords={'time':time,'lat':lat,'lon':lon})
ds4.pm25.attrs = {('long_name', 'Mean PM2.5 concentration'),
                  ('standard_name', 'pm25_concentration'),
                  ('units', 'kg m-3'),
                  ('_FillValue', fillv)}
ds = xr.merge([ds1, ds2, ds3, ds4])
ds.attrs = {('comment', 'Contact: knut.vonsalzen@canada.ca'),
            ('data_licence', '1) GRANT OF LICENCE - The Government of Canada (Environment Canada) is the \
owner of all intellectual property rights (including copyright) that may exist in this Data \
product. You (as \"The Licensee\") are hereby granted a non-exclusive, non-assignable, \
non-transferable unrestricted licence to use this data product for any purpose including \
the right to share these data with others and to make value-added and derivative \
products from it. This licence is not a sale of any or all of the owner\'s rights.\
2) NO WARRANTY - This Data product is provided \"as-is\"; it has not been designed or \
prepared to meet the Licensee\'s particular requirements. Environment Canada makes no \
warranty, either express or implied, including but not limited to, warranties of \
merchantability and fitness for a particular purpose. In no event will Environment Canada \
be liable for any indirect, special, consequential or other damages attributed to the \
Licensee\'s use of the Data product.')}
outfile = './pm25_downscaled_emulator_'+scenario+'_total.nc'
ds.to_netcdf(outfile)
                 
